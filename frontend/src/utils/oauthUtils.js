import { createApplication, editApplication } from "./applicationUtils";
import { baseURL, getUserInfo } from "./authUtils";
import { DateTime } from "luxon";

const setInterviewTime = async (interviews) => {
  if (interviews && interviews.length > 0) {
    // only use interviews that have date set
    const interviewDates = interviews.filter((interview) => {
      return interview.date;
    });

    interviewDates.forEach(async (interview) => {
      try {
        const response = await fetch(
          `${baseURL()}/applications/${interview.company}/${interview.title}`,
          {
            credentials: "include",
          }
        );
        if (!response.ok) {
          const text = await response.json();
          throw new Error(text.error);
        }

        // application to update interview time for
        const application = await response.json();

        if (application.id) {
          // check if interview date is assigned by an email, and if that email is the same one
          if (application.emailId !== interview.id) {
            const updated = editApplication(
              {
                interviewAt: interview.date,
                emailId: interview.id,
                categories: ["Autogenerated"],
              },
              application.id
            );
          } // if same email already used to set date, don't update
        } else {
          // no matching application found, make new one
          const newApplication = {
            appliedAt: new Date(),
            title: interview.title,
            companyName: interview.company,
            emailId: interview.id,
            interviewAt: interview.date,
            status: "Interview",
            description:
              "This application was auto-generated with information from an Interview Confirmation email. Make sure to check the details, as information may be incorrect.",
            categories: [{ name: "Autogenerated" }],
          };

          const created = await createApplication(newApplication);
        }
      } catch (error) {
        throw error;
      }
    });
  } else {
    // no new interviews to set
    return;
  }
};

const timeZoneAbbr = {
  EST: "America/New_York",
  EDT: "America/New_York",
  PST: "America/Los_Angeles",
  PDT: "America/Los_Angeles",
};

const findInterviewTimes = async () => {
  const interviews = [];
  try {
    // get user information based on current session

    const user = await getUserInfo();

    if (!user.google_id) {
      // not linked to a google account, no action necessary
      throw Error("User does not have a linked Google account.");
    }

    const data = await getMessages(user);

    if (data.messages) {
      // get each message and parse information to find interview time
      for (const message of data.messages) {
        const data = await getMessage(user, message);
        const newInterview = await parseMessage(message, data);

        if (newInterview) {
          interviews.push(newInterview);
        }
      }
    }

    updateEmailScanned();
    setInterviewTime(interviews);

    return interviews;
  } catch (error) {
    alert("No new interview times found from email.");
  }
};

const parseMessage = async (message, data) => {
  let bodyText = null;
  // if plain text email, read directly from body data
  if (data.payload.body.data) {
    const encodedText = data.payload.body.data;
    bodyText = atob(encodedText.replace(/-/g, "+").replace(/_/g, "/"));
  }

  // TODO: set up recursion for multipart email

  if (bodyText) {
    const newInterview = { id: message.id, duration: {} };
    // from text, find date using formatting for abbreviated or full month names
    // text needs to be in "Month dd, yyyy hh:mm ampm timezone" format
    const dateRegexFormat =
      /\b([A-Za-z]{3,9})\s(\d{1,2}),\s(\d{4})\s(\d{1,2}):(\d{2})\s([AP]M)(?:\s([A-Z]{2,4}))?\b/g;

    // TODO: instead search for dateString + timezone separately to avoid separating and then recombining parts
    let matchedText;
    // find meeting location as any characters before the next new line
    const positionRegexFormat = /Position:\s*(.*)\s*\n/;
    if ((matchedText = positionRegexFormat.exec(bodyText))) {
      newInterview.title = matchedText[1];
    } else {
      newInterview.title = "Unknown Position";
    }

    const companyRegexFormat = /Company:\s*(.*)\s*\n/;
    if ((matchedText = companyRegexFormat.exec(bodyText))) {
      newInterview.company = matchedText[1];
    } else {
      newInterview.company = "Unknown";
    }

    if ((matchedText = dateRegexFormat.exec(bodyText))) {
      // get each value and separate timezone
      const month = matchedText[1];
      const day = matchedText[2];
      const year = matchedText[3];
      const hour = matchedText[4];
      const minute = matchedText[5];
      const ampm = matchedText[6];
      let timezone;
      if (matchedText[7]) {
        timezone = matchedText[7];
      } else {
        timezone = "local";
      }

      // string recombining parts into needed format (minus timezone)
      const date = `${month} ${day}, ${year} ${hour}:${minute} ${ampm}`;
      // fromFormat(text: string, fmt: string, opts: Object)
      const parsedDate = DateTime.fromFormat(date, "LLLL d, yyyy h:mm a", {
        zone: timeZoneAbbr.timeZone,
      });
      const interviewDate = new Date(parsedDate.toISO());
      newInterview.date = interviewDate;
    }
    // find meeting location as any characters before the next new line
    const locationRegexFormat = /Location:\s*(.*)\s*\n/;
    if ((matchedText = locationRegexFormat.exec(bodyText))) {
      newInterview.location = matchedText[1];
    } else {
      newInterview.location = "Unknown Location";
    }

    // find duration as "number unit" with optional second "number unit" (if hours and mintutes)
    const durationRegexFormat = /Duration:\s*(\d*)\s*(.*)\s*(\d*\s*.*)?\n/;
    if ((matchedText = durationRegexFormat.exec(bodyText))) {
      if (
        matchedText[2] === "hr" ||
        matchedText[2] === "hour" ||
        matchedText[2] === "hrs" ||
        matchedText[2] === "hours"
      ) {
        newInterview.duration.hours = matchedText[1];

        if (matchedText[3]) {
          newInterview.duration.minutes = matchedText[3];
        }
      } else {
        newInterview.duration.minutes = matchedText[1];
      }
    }

    // find interviewers as "firstname lastname" with option comma-separated list
    const attendeesRegexFormat =
      /Interviewer(\(s\))?:\s*(\w*)\s*(\w*)(,\s*\w*\s*\w*)*\s*\n/;
    if ((matchedText = attendeesRegexFormat.exec(bodyText))) {
      newInterview.interviewee = matchedText[2] + matchedText[3];
    }

    return newInterview;
  }
  return null;
};

const getMessages = async (user) => {
  let searchTime = null;
  let apiURL = `https://gmail.googleapis.com/gmail/v1/users/${user.email}/messages?includeSpamTrash=true&q=subject:(Interview Confirmation) to:${user.email}`;
  if (user.emailScanned) {
    const scanDate = new Date(user.emailScanned);
    searchTime = Math.floor(scanDate.getTime() / 1000);
    apiURL = `https://gmail.googleapis.com/gmail/v1/users/${user.email}/messages?includeSpamTrash=true&q=subject:(Interview Confirmation) to:${user.email} after:${searchTime}`;
  }
  try {
    const response = await fetch(apiURL, {
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${user.access_token}`,
      },
    });
    if (!response.ok) {
      const text = await response.json();
      throw new Error(text.error || "Failed to fetch messages.");
    }

    const data = await response.json();
    return data;
  } catch (error) {
    throw error;
  }
};

const getMessage = async (user, message) => {
  try {
    const response = await fetch(
      `https://gmail.googleapis.com/gmail/v1/users/${user.email}/messages/${message.id}`,
      {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${user.access_token}`,
        },
      }
    );
    if (!response.ok) {
      const text = await response.json();
      throw new Error(text.error);
    }

    const data = await response.json();

    return data;
  } catch (error) {
    throw error;
  }
};

const updateEmailScanned = async () => {
  try {
    const response = await fetch(`${baseURL()}/user`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ emailScanned: new Date() }),
      credentials: "include",
    });
    if (!response.ok) {
      throw new Error();
    }
  } catch (error) {
    throw new Error("Failed to update user profile");
  }
};

export { findInterviewTimes, setInterviewTime };
